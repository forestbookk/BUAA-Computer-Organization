# P0-Logism状态机

## 总结

> 没思路就从最基础的状态转移电路入手，手搓

## 课下

### 复习总结

* 寄存器初始化使用到的counter：勾选Stay At Value（如果出现某个不减的信号突然减了，可能是这个原因）。
* Comparator的符号性需要检查
* state_module和output_module精神永存。
* 评测相关：端口没有clk而评测有，不用时序电路；few outputs：输出不变引起的过滤、appearance
* 一些部件的实用功能：DMX的Three-State，Counter的Stay At Value

### 题目

* CSC

端口没有clk而评测电路有clk时，不建议使用时序电路。自带的时钟和评测的时钟基本不同步，将导致WA。

* GRF

few output: 考虑**输出不变引起的过滤**，或时序问题（tle，或期待输出非零值时输出了0），或appearance问题。

DMX-three-state: yes

WE(写使能信号): 连到寄存器的Enable端

* ftoi

小数左移：如何保存溢出部分？Bit Extend ->  左移 -> 右移(小数原位宽)

* P1_L2_intcheck

  * 题目要求简介：用verilog编写一个字符状态机，串行输入，正则为`int 标识符{, 标识符};`。
  
  * **特殊要求**：`;`为语句结束标志，当时钟上升沿出现它则开始判定整个语句是否符合规范。注意，这与以往做的状态机都**不同**，以往是边读边判断，所以可以从中间截取出有效字符串视为有效，而这题不可以！**分号出现前，任何偏差都会导致整个语句一定不过关**。设计过程中最值得注意的是**每个语句的初始状态**。
  
  * 易错点
  
    事实上这道题，我已经听同学说过大概的思路了。但还是卡在很多易错点上。
  
    * 数字字面量[**位宽**]'[进制]值：~~例如我把状态量设成了2'b1011等等而不自知，导致status一直卡在3不动~~
    * 条件判断：检查**||**和**&&**
    * 制表符`\t`, 注意斜杠方向
    * **所有**状态：不缺不漏。最后的一个点就是这个
  
* P1_L1_drink

  * 题目要求简介：verilog编写一个饮料投币机器，售价为2元，只能投5角或1元
  
  * **特殊要求**：出货周期，投币仍然有效（且在每个时钟上升沿收到coin后判断输出置位）。以下是设计分析。
    * 出货周期，投币有效：当时钟上升沿遇到coin且判定可以出货（投币机收到了大于等于2元的货币），应将输出置位1，次态应为**初始态**。
    * 出货周期，投币无效：输出置位1，次态应为**出货态**。那么当下一个投币来到时，因为投币无效，所以出货态遇到coin无条件（根据设计要求可以灵活改变）跳转初始态。
    
  * 易错点：在做题的过程中，可能发生**状态临时修剪**改变，这时候要仔细顺一下**状态转移图的逻辑**。
  
  * 不过可喜可贺，wa了一次，找到如上点，很快AC了
  
* P1_L1_vote_plus

  * 题目要求简介：verilog编写一个投票表决器，投票器类型分为np、vip和vvip。人数和权值如下表。模块在每个时钟上升沿读取投票信号并更新权值。

    | 投票者类型 | 人数 | 每票权值 |
    | :--------: | :--: | :------: |
    |     np     |  32  |    1     |
    |    vip     |  8   |    4     |
    |    vvip    |  1   |    16    |

  * 端口：
  
    |  信号名  | 方向 |              描述               |
    | :------: | :--: | :-----------------------------: |
    |   clk    |  I   |            时钟信号             |
    |  reset   |  I   |      异步复位，高电平有效       |
    | np[31:0] |  I   | 每一位代表一个np（高电平有效）  |
    | vip[7:0] |  I   | 每一位代表一个vip（高电平有效） |
    |   vvip   |  I   |   代表一个vvip（高电平有效）    |
    |  result  |  O   |            当前权重             |
  
    要计算权值，先要**计算信号中1的个数**。硬件中，verilog可以使用位选择符，而logism可以将位相加，Bit Adder。于软件而言，移步Math.md
  
  *  **特殊要求**：若某一投票者已经投过票，则将其视为**在以后的每个时钟周期内均投票**。短短的一句话，因此不能确定已经投过票的人是否会再次投票，也就是**某位是否会反复置位**。
  
    * 顶层设计：使用LogismFSM的设计。分为state_module和output_module.
    
    * state_module: 次态 = 现态 | 输入
    
    * output_module
    
      ```verilog
      wire i = 现态[i:i]<输入[i:i] ? [权值] : 0;//第i位投票者是否在本轮投票
      result <= result + i{, index};
      ```
    
      善用C语言等工具生成批量代码、数据等。
  * 易错点：左移和右移的方向应确定。    



### FSM

#### 电路模型

* Mealy同步复位

  ![P0-Logism状态机-Mealy同步复位](D:\BUAA\STAR\CO_LAB\img\P0-Logism状态机-Mealy同步复位.jpg)

* Mealy异步复位

  ![P0-Logism状态机-Mealy异步复位](D:\BUAA\STAR\CO_LAB\img\P0-Logism状态机-Mealy异步复位.jpg)

* Moore同步复位

  ![P0-Logism状态机-Moore同步](D:\BUAA\STAR\CO_LAB\img\P0-Logism状态机-Moore同步.jpg)

* Moore异步复位

  ![P0-Logism状态机-Moore异步复位](D:\BUAA\STAR\CO_LAB\img\P0-Logism状态机-Moore异步复位.jpg)



