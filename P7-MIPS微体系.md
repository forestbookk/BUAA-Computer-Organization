# MIPS微体系

## 1.结构

### 1.1.计时器

> ~~课程组提供

* 主要功能：根据设定的时间来定时产生中断信号。
* 内部工作：需要定义多个程序员可见寄存器和若干用于完成功能的程序员不可见方法内部寄存器

### 1.2.系统桥

> ~~为CPU提供统一的访问外设的接口

* 实现：必须作为独立MODULE实现，不能包含在CPU内部。编写参考——gxp`L15-支持I/O`

* 功能：**响应中断发生器。通过`store`类指令访问地址`0x7F20`即可。**

  > P7微系统应满足以下2个能力：
  >
  > * 可以通过外部端口接受外部中断信号（已在Timer部分实现）
  > * 可以通过`store`类指令访问地址`0x7F20`，改变对应的微系统输出信号（`m_int_addr`, `m_int_byteen`），即系统桥实现正确。

* 与外设沟通：通过CPU视图下的一个内存地址，读写响应数据。

  内存：外设的若干寄存器。系统桥传入对地址的访问请求后，通过系统桥内部的转换代码，将请求转变为对相应寄存器的读写操作。

  **属于P7的地址空间设计——与SEE MIPS RUN LINUX和PPT的设计不同**

  |         条目         |     地址或地址范围      |        备注        |
  | :------------------: | :---------------------: | :----------------: |
  |      数据存储器      | 0x0000_0000∼0x0000_2FFF |                    |
  |      指令存储器      | 0x0000_3000∼0x0000_6FFF |                    |
  |       PC初始值       |       0x0000_3000       |                    |
  | 异常处理程序入口地址 |       0x0000_4180       |                    |
  |  计时器0寄存器地址   | 0x0000_7F00∼0x0000_7F0B | 计时器0的3个寄存器 |
  |  计时器1寄存器地址   | 0x0000_7F10∼0x0000_7F1B | 计时器1的3个寄存器 |
  |  中断发生器响应地址  | 0x0000_7F20∼0x0000_7F23 |                    |

  

### 1.3.协处理器

> ~~设置CPU的异常处理功能，反馈CPU的异常信息

* 实现参考：gxp`L13-MIPS系统结构-V1`

* 指令：`MFC0`, `MTC0`

  * `MFCO` ：读取CP0寄存器至通用寄存器
  * `MTCO` ：通用寄存器值写入CP0寄存器 

* 位置：CP0放在D级或E级或M级。CP0和宏观PC处于同一流水级

* 功能：1）对异常进行配置；2）记录异常信息

* 实现寄存器：SR(12)-配置异常的功能, Cause(13)-记录异常发生的原因和情况, EPC(14)-记录异常处理结束后需要返回的PC

  当发生异常时，CPU自动将异常信息写入CP0的相应寄存器。异常处理程序会访问响应寄存器以了解异常的信息，进行异常处理。

  | 寄存器 | 功能域  | 位域  |                             解释                             |
  | :----: | :-----: | :---: | :----------------------------------------------------------: |
  |   SR   |   IM    | 15:10 | 位域分别对应6个外部中断。1-允许中断；0-禁止中断。被动功能，只能通过`mtc0`指令进行修改。 |
  |   SR   |   EXL   |   1   | 任何异常发生时置位->强制进入异常处理程序（核心态），并禁止中断。“🔒”。硬件和软件的交互位，硬件置位，软件清除。 |
  |   SR   |   IE    |   0   |             全局中断使能。1-允许中断；0-禁止中断             |
  | Cause  |   BD    |  31   |        1-EPC指向当前指令的前一条指令；0-指向当前指令         |
  | Cause  |   IP    | 15:10 | 为 6 位待决的中断位，分别对应 6 个外部中断，1-有中断；0-无中断。每个周期被修改一次，修改内容来自计时器和外部中断。 |
  | Cause  | ExcCode |  6:2  |     **流水到CP0所在流水级**。异常编码，记录当前异常内容      |
  |  EPC   |         |       | 记录异常处理结束后需要返回的PC。若异常指令是延迟槽指令，那么存的是异常指令的PC-4，否则存异常指令的PC |

  

* 异常码-EPC

  在异常处理程序中，需要访问Cause的ExcCode域以获取异常原因。

  故ExcCode的编码必须遵守规范。编写表格——P7教程

### 1.4.内部异常检测与流水

> ~~CPU应可以检测内部指令执行错误

#### 每条指令的W阶段检测

* 最终异常：流水过来的前级异常
* 是否有中断

#### 中断检测时判断是否中断允许位

* 解决方法：用HWINT / IM / IE / EXL产生中断请求

#### 中断优先级高于异常

* 实现：清除各级指令时，先判断中断再判断异常流水标志位

### 1.5.外部中断响应

> ~~CPU应能初步响应外部中断信号

### 1.6.异常处理指令

> ~~部分指令需要进行异常处理

### 1.7.单周期CPU的封装

> ~~CPU从外部看上去是一个单周期CPU

* 宏观PC

  表示该指令之前的所有指令序列对CPU的更新已完成，该指令及其以后的指令序列对CPU的更新未完成。

  实现上，宏观PC通常以某一个流水级CPU作为界限，作为输出端口输出。这个流水级一般是CP0所在流水级。

* 精确异常

  * 异常受害指令：该指令导致了异常

  * 精确异常的性质：异常受害指令前面的所有指令都执行完毕。当异常处理结束后重新执行受害指令及其后续指令，与未发生异常时执行这些指令的效果一样。

  * 实现：

    * 清空流水线

      清空宏观PC之后的指令所在的流水线寄存器，flush。

      流水线寄存器的信号优先级如下：

      |     信号      |      优先级      |
      | :-----------: | :--------------: |
      |     reset     | 最高（同步复位） |
      |      Req      | 次高（中断请求） |
      | flush / stall | 最低（刷新暂停） |

      需要优先级的寄存器的位段：

      * PC寄存器
      * CP0`Cause`寄存器的`BD`位：在flush时保持原来的信息。

### 1.8.异常处理程序

> ~~利用MARS编写简单的异常处理程序

* `eret`没有延迟槽

  设计应保证`eret`的后续指令不被执行

* 程序结构

  1. 构造异常处理环境，保存现场

     将所有寄存器都保存在堆栈中

  2. 读取Cause和EPC寄存器，判断错误类型

  3. 根据异常类型和其他属性执行对应处理

  4. 恢复现场

     从堆栈中恢复所有寄存器

  5. 执行`eret`指令从异常处理程序返回

* 利用MARS验证——中断/异常处理的框架是否正确

![P7-structure](D:\BUAA\STAR\CO_LAB\img\P7-structure.bmp)

## 2.计算机系统设计概念

### 2.1.中央处理器（CPU）

进行数据的加工和处理。

### 2.2.外设

MIPS微体系包含的外设（外部设备）主要有以下三种，每个外设都和CPU地位平等。

#### 计时器（Timer）

计算机系统中的计时部件，可以按照配置定时地产生时钟中断。

#### 存储器（Memory）

计算机系统中的存储部件，用于存储指令和数据。即P6课程组提供的外接IM和DM。

#### 中断发生器（Interrupt Generator）

抽象的计算机系统外设，会随机地产生外部中断信号。中断信号在CPU响应前会持续置高。

## 3.支持异常处理流的CPU

### 3.1.异常处理流

异常处理流，指CPU在执行程序的指令的时候，会发生一些“事件”，改变程序的原有流向，让PC跳转到特定的地址。

当指令执行错误时，可以产生一个“事件”，那么CPU就会跳转到一个处理这种执行错误的程序中执行，在处理结束后再跳转回原来的程序，注意，并不一定是“事件”来临前的地址。可以将异常处理流视为“发生位置不确定的过程调用”。

对于外设的信号，我们将其视为一个“事件”，当“事件”来临时，CPU会做出上述举动。

### 3.2.仅限P7生效的特定概念

“事件”分类：

|   概念   |   产生原因   |          举例          |
| :------: | :----------: | :--------------------: |
| 内部异常 | 指令执行错误 |  加法溢出，除法除零等  |
| 外部中断 | 外部设备信号 | 计时器信号，键盘输入等 |

统称为“异常”。为了响应异常，CPU自动跳转到特定地址（PC修改），然后进行异常处理。

## 4.软硬件接口

### 4.1.接口的设计

**高内聚，低耦合**，接口设计应足够简洁。

### 4.2.外设的接口设计-系统桥

系统桥：连接CPU和外设的功能设备，提供CPU接口，使CPU可以按地址读写外设。系统桥统一并简化了CPU的对外接口，即CPU不需要为每种外设单独提供接口。

### 4.3.CPU的接口设计-封装成单周期CPU

==将复杂的多级流水线CPU封装成单周期CPU==，这是理解P7任务的关键。



## 5.整体要求

* CPU必须为流水线
* 微系统必须支持中断和异常
* 除特定声明外，微系统设计以《See MIPS Run Linux》为准。测试时以《See MIPS Run Linux》为准，而非MARS。

### 顶层接口

增加：

- `interrupt`：外部中断信号。由中断发生器产生，每次中断信号会持续到处理器响应该信号。请注意，处理该中断信号的方式应和处理 Timer 产生的中断不完全相同，具体见前面的教程。
- `macroscopic_pc[31:0]`：详细概念见[宏观 PC](http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-4/#pc)。我们保证评测过程中宏观 PC 仅用于定位指令，作为产生外部中断信号的条件。
- `m_int_addr[31:0]`：中断发生器待写入地址。当该信号命中中断发生器响应地址，且字节使能信号有效时，视为响应外部中断。
- `m_int_byteen[3:0]`：中断发生器字节使能信号，当该信号任意一位置位时视为有效。

### 硬件约束

* 顶层模块至少包含CPU, Bridge，Timer0，TIME1
* 地址空间——系统桥
* 主要部件
  - CPU：在 P6 基础上进行增量开发，增加 CP0 协处理器，支持异常和中断等。
  - CP0：见[CP0约束](http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-6/#cp0)。
  - Bridge：须作为独立的 module，不包括在 CPU 中；访问外设均须通过系统桥。
  - IM：容量为 **16KiB**（**4096** × 32bit）。
  - DM：容量为 **12KiB**（**3072** × 32bit）。
  - Timer：定时器官方源代码已经给出，无需自行设计实现。
  - 中断发生器：
    - 中断信号依据宏观 PC 产生，依据相应的待写入地址和字节使能信号关闭，具体实现参考下发的 tb。
    - 由于其内部并没有真正的存储单元，我们规定读出的数据始终保持 0，且写入时除了响应中断外不会产生其他影响。

### CP0约束

* 位置：M级
* 输出要求：无需display
* 必须实现的寄存器：SR, CAUSE, EPC
* 寄存器规范：
  * CP0 寄存器的初始值均为 0，未实现位始终保持 0。
  * 当进入中断或异常状态时，均需要将 EXL 置为 1，用以屏蔽中断信号（注意《SMRL》中并没有指定进入中断时 EXL 的值）；当退出中断或异常状态时，也均需要将 EXL 置为 0，取消屏蔽中断信号。
  * Cause 寄存器的 IP 域每周期写入 HWint 对应位的值。
  * 当进入中断或异常状态时，需要将受害指令的 PC 写入 EPC。

### 指令约束

增加 `mfc0, mtc0, eret, syscall` 四条新指令。

- `eret` 具有跳转的功能但是没有延迟槽，你的设计应该保证 `eret` 的后续指令不被执行。
- `syscall` 指令行为与 MARS 不同，无需实现特定的输入输出功能，只需直接产生异常并进入内核态。

### 中断异常约束

* 异常入口：`0x4180`

* 嵌套中断异常：不需实现

* 优先级：中断优先级>异常优先级。即当有异常提交至 CP0 寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。

* 精确异常：

  - 除下面的情况外，对所有中断异常的处理都应遵循[精确异常](http://cscore.buaa.edu.cn/tutorial/P7/implement/P7-2-4/#_1)的处理规则。

  - 在进入中断或异常状态时，如果受害指令及其后续指令

    已经改变

    了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E 级，考虑以下情况：

    - `mult` 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。
    - `mthi` 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，`mtlo` 同理。
    - `mult` 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。
    - `mthi` 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，`mtlo` 同理。

- 中断规范：
  - Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。
  - 规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入 EPC。

* MIPS微系统需支持的异常

  | ExcCode | 助记符  |               描述               |
  | :-----: | :-----: | :------------------------------: |
  |    0    |   Int   |               中断               |
  |    4    |  AdEL   |       取数或取值时地址错误       |
  |    5    |  AdES   |          存数时地址错误          |
  |    8    | Syscall |             系统调用             |
  |   10    |   RI    |    不认识的（或非法的）指令码    |
  |   12    |   Ov    | 自陷形式的整数算数指令导致的溢出 |

* 补充说明：

  - **分支跳转指令无论跳转与否，延迟槽指令为受害指令时 `BD` 均需要置位。**
  - 发生取指异常或 `RI` 异常后视为 `nop` 直至提交到 CP0。
  - **跳转到不对齐的地址时，受害指令是 PC 值不正确的指令（即需要向 EPC 写入不对齐的地址）。**
  - 对于未知指令的判断仅需考虑 opcode（和 R 型指令的 funct），且仅需判断是否出现在 P7 要求的指令集中，同时保证未知指令的测试用例中 opcode 和 funct 码的组合一定没有在 MARS 的基本指令集中出现。

### 官方测试说明

* 允许从`0x417c`直接前进到`0x4180`，此时CPU行为与P6一致。不应有中断响应等其他行为
* 测试数据规范
  - 测试时不会出现跳转到未加载指令的位置的情况。
  - `eret` 只会出现在中断处理程序中，后可能紧跟另一条非 `nop` 的指令。
  - 测试程序保证不会写入 Cause，但可能写入 SR 和 EPC。
  - 测试程序只会通过指令 `sb $0, 0x7f20($0)` 访问中断发生器（响应中断），且只会在中断处理程序中访问。
  - 中断处理程序会对寄存器和内存进行读写来验证 CPU 的正确性。
  - 中断处理程序执行过程中保证不出现异常，且不会产生中断。

## 6.解读教程

### 6.1.明确P7目标

* 更改流水线各级，使之可以产生异常
* 添加CP0处理异常
* 添加Bridge和两个外设（计时器）进行交互

### 6.2.异常/中断处理的理解

视为新增两个跳转信号。

* 跳入异常处理程序：入口地址固定为`0x4180`。跳转条件是指令执行时产生异常或外设发出中断信号。跳转行为还包括将受害指令地址写入EPC。

  实现：更改流水线各级，产生异常。将异常流水到M_CP0。CP0若决定处理，则跳转。

* 遇到`eret`跳回EPC地址：D级判断。若出现eret，则置位F_PC和NPC分别为EPC和EPC+4

| 异常与中断码 |  助记符与名称  | 指令与指令类型 |                       描述                       |
| :----------: | :------------: | :------------: | :----------------------------------------------: |
|      0       | Int(外部中断)  |    所有指令    |         中断请求，来源于计时器与外部中断         |
|      4       | AdEL(取指异常) |    所有指令    |                  PC地址未字对齐                  |
|      4       | AdEL(取指异常) |    所有指令    |           PC地址超过 `0x3000 ~ 0x6ffc`           |
|      4       | AdEL(取数异常) |       lw       |              取数地址未与4字节对齐               |
|      4       | AdEL(取数异常) |       lh       |              取数地址未与2字节对齐               |
|      4       | AdEL(取数异常) |     lh，lb     |                取Timer寄存器的值                 |
|      4       | AdEL(取数异常) |     load型     |                计算地址时加法溢出                |
|      4       | AdEL(取数异常) |     load型     | 取数地址超出DM, Timer0, TIMEr1, 中断发生器的范围 |
|      5       | AdES(存数异常) |       sw       |               存数地址未4字节对齐                |
|      5       | AdES(存数异常) |       sh       |               存数地址未2字节对齐                |
|      5       | AdES(存数异常) |     sh，sb     |                存Timer寄存器的值                 |
|      5       | AdES(存数异常) |    store型     |                计算地址时加法溢出                |
|      5       | AdES(存数异常) |    store型     |            向计时器的count寄存器存值             |
|      5       | AdES(存数异常) |    store型     | 存数地址超出DM, Timer0, TIMEr1, 中断发生器的范围 |
|      8       |    Syscall     |    syscall     |                     系统调用                     |
|      10      |       RI       |       -        |                    未知指令码                    |
|      12      |       Ov       | add，addi，sub |                     算术溢出                     |

需要修改的流水级：

* F级PC：PC地址未对齐 / 超出范围
* D级CU：RI / Syscall / eret
* E级ALU：算术溢出（Ov / AdEL / AdES）
* M级DM：地址未对齐 / 地址超出范围 / 访存Timer寄存器的值 / 向计时器的count寄存器存值

## 7.添加指令

* 正常执行

  1. 控制信号真值表，添加对应模块逻辑

  2. Stall & Forward

* 异常执行

  1. CPU产生异常

     * 何级判断异常
     * 异常码生成

  2. CP0检测