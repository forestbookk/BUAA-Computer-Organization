# 简易多周期流水线CPU（1）

## 课下复习

### 有符号数

`RTL：GRF[rs]<0`：verilog写法`$signed()<0`

注意：32'h8000_0000没有相反数。故虽然32'h8000_0000和32'h8000_0000相加为0，但它们并不互为相反数。

### 指令添加套路

#### 计算

* 修改ALU
* 生成T~use~和T~new~真值表，判断指令类型。更新Stall`AT`表达式
* 根据T~new~更新Forward值和转发表达式

#### 跳转

##### 跳转类型总览

* BxxZAL：跳转，**无条件链接** ~~> 

  ```
  D_A3=5'd31
  ```

* BxxZALC：跳转，**条件链接** ~~> 

  ```
  RFWrEn=('bxxzalc || ...) ? 1 : 0; //即使条件不成立，写的寄存器是$0，一样达成不写且不转发的目的。
  D_A3=(CMPOp==`CMPOp_BxxZALC) ? (D_b_jump?5'd31:0):
       ......
  ```

* BxxZALR：跳转，链接到指定寄存器

* BxxZALL：**条件清空延迟槽**。注意**阻塞时不可清空**。因为写使能`WE = !Stall`，所以设计如下：

  ```
  //mips.v
  assign FD_REG_flush = (CMPOp==`CMPOp_BxxZALL && !D_b_jump) ? 1 : 0;
  //FD_REG.v
  if(reset || (WE && flush))
  ```

##### Stall&Forward

因为我们在D级获得完整的判断信息，所以SF部分并不陌生。

* 生成T~use~和T~new~真值表，判断指令类型。更新Stall`AT`表达式
* 根据T~new~更新Forward值和转发表达式

#### 访存

* 条件访存

  在M级才知道”存在哪里，存什么“，为DM设置A3的IO口，视情况增加特定寄存器的I口，在DM中设置判断，更新A3值。在W级和W_RW合流。

  暂停值得特别注意：在D级阻塞所有可能用到**条件访存可能写的寄存器**的指令。因为**A3在W级（不包含W级）之前都不确定**，所以应该写成：

  ```
  Stall_rs_E = ((E_lrm ? D_rs_addr : D_rs_addr==E_A3) && D_rs_addr && T_new_E > T_use_rs) ? 1 : 0;
  Stall_rs_M = ((M_lrm ? D_rs_addr : D_rs_addr==M_A3) && D_rs_addr && T_new_M > T_use_rs) ? 1 : 0;
  ```
  
  

## 设计目标

给定任意指令集，确保基于该指令集的任意程序均能全速运行。

* 功能：能发现**所有可能导致冒险**的指令组合
* 性能：**尽力转发**。凡能转发，绝不暂停。
* 延迟槽：b类和j类必须支持延迟槽。因此设计需要注意使用**PC@D+8**

## 流水线架构

### 数据通路

4个Reg保存本级中指令需要的所有信息。

分布式译码。4个CU管理级次中的行为。

设置Stall.v和Forward.v管理E, M, W级的暂停和转发机制。内部进行译码，结构类似于CU。

### 功能部件规划

功能部件主要有以下部分，构成一条数据通路，以PC和RF为起始点，共5层级。

而CU提供D,E,M,W各级中指令所需要的控制信号。故CU应有4个，针对本级指令进行译码，即**分布式译码**的做法。

* PC RF: start_point & end_point
* F级: IM
* D级: RF, EXT, NPC, CMP
* E级: ALU
* M级: DM
* W级: 无

### 译码风格

课程组提供了两种方式：

> #### 指令驱动型
>
> 根据指令，集中对大量控制信号进行赋值。
>
> #### 控制信号驱动型
>
> 根据控制信号，以指令的或逻辑进行赋值。

根据P3和P4的上机经验，控制信号驱动型对顶层部署有利好。而我的问题可以采用**列表核对**的方式解决。

### 流水线寄存器

对流水线寄存器，我们可以说，**每个流水线寄存器都保存着一条指令完成后续操作所需要的的全部信息**。

那么我们首先要明确的是**每一级都需要什么数据**，**每一级又向后输出什么数据**。

首先，Instr和PC必须跟随流水线一起传递。

#### D级部件功能具体应该如何实现？

Branch信号由CMP发出，NPC接受，故为D级内部产生消费，不进行特殊命名。与PC相关的NPC和PC4统一以前缀D命名。

D_CMP, D_EXT, D_NPC需要的操作数基本上都来自本级本指令的信息，除了Instr和PC。采用内部转发，应当是较好操作的。目前棘手的是D_RF_A3和D_RF_WD，也就是RF的写功能，它执行之前指令的行为。高老板的PPT是将RF的写功能和读功能分开，这可以理解，但具体应该怎么操作？

我最初的想法是通过D_CU对写使能的控制，分离读写。但现在仔细想想，是不可行的。倘若在D级进行读和写的工作，这两个功能使用的信息来自不同的指令。那么指令的流水就会出现混乱。而从硬件基础上把RF复制成两份分别读写显然也是不易实现的，而且这个设计十分不美观科学。因为读写是相互依存的。当写RF更新后，读RF势必要同时更新。否则会造成严重的冒险事故。

所以现在的想法是用D_CU控制RF的读逻辑，W_CU控制RF的写逻辑。而回写逻辑仍然放在D级的RF中。

#### **分支造成的冒险如何解决？**

解决方案1：尽力转发，考虑暂停。

解决方案2：在D级放置比较器，尽快得到B指令结果。当需要转移时，清除D级即可。

但会产生数据相关的冒险（可能依赖于前序指令的结果）。事实上会产生寄存器结果的指令有：计算指令、load指令和链接指令。接下来进行讨论：

* 前序指令含计算指令。

  * 计算指令在E级：只能暂停。

  * 计算指令在M级：结果已经产生，转发。

  * 计算指令在W级：结果已经产生，转发

* 前序指令含load指令。
  * load指令在E级：只能暂停。
  * load在M级：只能暂停。
  * load在W级：结果已经产生，转发。
* 前序指令含链接指令。
  * 链接指令在E级：结果已经产生，转发。 
  * 链接指令在M级：结果已经产生，转发。 
  * 链接指令在W级：结果已经产生，转发。
  * 
    事实上，举例jal，结果在D级就已经产生，是不是可以跳过E, M, W级直
  * 接写入RF了？我认为暂时是可以的。

| 产生寄存器结果的指令类型 | 产生结果的级数 |  数据冲突  |
| :----------------------: | :------------: | :--------: |
|           链接           |       D        |     无     |
|           计算           |       M        |  D, E, M   |
|           load           |       W        | D, E, M, W |

解决方案3：分支延迟槽。常规上，分支指令是以PC+4为基地址加偏移来计算偏移地址。由于在分支指令后人为放一条指令，因此转移地址就多了4，故支持延迟槽的CPU需要自动用PC+8作为基地址（我们可以发现MIPS_Vol2_指令集就是这样描述的）。同样地，对于**jal**，可以放置一条空指令，那么**保存在GRF[31]的地址应是D_PC+8或F_PC+4**。

延迟槽基本上不需要实现。只要不考虑F级指令的作废问题，就是实现了延迟槽。至于延迟槽中的指令到底是什么，是由编译器决定的，不需要CPU设计者操心。**编译器保证延迟槽中的指令不能为分支指令或跳转指令**。

#### **转发机制如何实现？**

我们要求**所有转发数据都来源于流水寄存器而不能是功能部件**。只有来自流水寄存器中的数据百分百确定是本指令需要的信息。功能部件的输出随时变化，具有极强的不确定性，转发数据可能不是本指令需要的。

beq前移至D级，则D级还必须考虑rs和rt暂停和转发！参照上述“分支造成的冒险如何结局”



## 方法概述

基本思路：目标是构造全速流水线，故**转发**是**暂停**的前提。

1. 【转发】：构造无转发的基础流水线
2. 【转发】：增加转发电路
3. 【暂停】：根据RTL和流水线架构，构造每条指令的**T~use~**和**T~new~**
4. 【暂停】：构造暂停\转发**策略矩阵**（**覆盖性分析**）
5. 【暂停】：根据策略矩阵生成**暂停**控制表达式
6. 【暂停】：根据策略矩阵生成**转发**控制表达式

## 转发

### 转发实现

在需求者前加上MUX。需求者与MUX的选择信号参看以下两节“需求者”和“选择数据”。

转发MUX和普通MUX之间的关系是什么？

注意：**只有RS和RT会被转发**，所以只要在普通MUX的RS和RT端口前面加上转发MUX。

### 需求者

* CMP的两个输入端口

* ALU的两个输入端口

* NPC的RA输入端

* DM的写数据输入端

  

### 选择数据

#### 就近法则

新值距离D越近，则意味着新值越“新鲜”。故距离D越近，转发的优先级越高，反之越低。

E级转发优先级最高；M级次之；W级转发优先级最低。

|    转发输出    | 恰在本级产生寄存器结果的指令 |
| :------------: | :--------------------------: |
|     DE_REG     |        J_L / ==LUI==         |
|     EM_REG     |       CALC_R / CALC_I        |
|     MW_REG     |             LOAD             |
| 寄存器内部转发 |                              |

* 优先级：规划MUX的端口优先级，数字越大优先级越高

#### 接受条件

* 供给端的寄存器地址与当前的相同
* 当前需要的地址不为0
* 供给端可以转发
* 供给端的指令会写数据

## 暂停

### 暂停实现

在D级暂停，加入气泡。因此要给ifu和FD_REG、DE_REG加上使能信号。使能信号处于低电平时，将Instr值置0，用initial块实现。

### 需求者的最晚时间模型·T~use~

T~use~：指令进入D级后，其后的某个功能部件再经过多少cycle就**必须**要使用寄存器值

### 供给者的最早时间模型·T~new~

T~new~：位于E级及其后各级的指令，再经过多少cycle能够产生要写入寄存器的结果。

### 暂停转发的基本方法

A指令位于D级，将A的T~use~与位于E/M/W各级指令的T~new~比较。若T~new~大，则暂停，否则转发。

### 暂停机制构造方法

#### 注意事项

* 只关注每条指令的操作语义
* 指令可能有2个不同的T~use~

#### 真值表

* T~use~：无定义处应取极限大值。避免stall误触发。

|  指令  | T~use~^rs^ | T~use~^rt^ |
| :----: | :--------: | :--------: |
| Calc_r |     1      |     1      |
| Calc_i |     1      |  <u>3</u>  |
|  Lui   |     0      |     0      |
|  Load  |     1      |  <u>3</u>  |
| Store  |     1      |     2      |
| Branch |     0      |     0      |
|   Jr   |     0      |  <u>3</u>  |

* T~new~：无定义处应取0。避免stall误触发。

| 指令类型 | T~new~@E | T~new~@M | T~new~@W |
| :------: | :------: | :------: | :------: |
|  Calc_r  |    1     |    0     |    0     |
|  Calc_i  |    1     |    0     |    0     |
|   Lui    |    0     |    0     |    0     |
|   Load   |    2     |    1     |    0     |
|  Store   |    0     |    0     |    0     |
|  Branch  |    0     |    0     |    0     |
|   J_l    |    0     |    0     |    0     |

## 课上测试

机房的电脑感染病毒，临时使用虚拟机。

虚拟机的shared/D和外机的D盘映射，所以可以在外机D盘直接查看文件。

**注意：文件命名统一使用英文名！**

课程组的Mars打开说明：双击Mars.sh

1. 计算
2. bsveall ： 无条件跳转，条件清空延迟槽
3. lwrev：条件存储，M级才知道存在哪儿
   * EXTOp：第一遍忘了添加控制信号
   * Stall信号
     * 复制后没有修改，导致rs相关控制了rt的阻塞。
     * 特判的是**E/M**级指令是否为lwrev
